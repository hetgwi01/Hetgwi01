  📅 상세 프로젝트 구현 및 기술적 해결 보고서 (Final Revised)

  작성자: hetgwi01
  프로젝트: Daiso-Shop (MSA 기반 도서 쇼핑몰)
  주요 역할: 도서(Product) 도메인 리드 개발, 백엔드 성능 최적화, 프론트엔드 통합

  ---

  1. 도서 도메인 모델링 및 코어 아키텍처 (2025.11.12 ~ 2025.11.20)

  쇼핑몰의 핵심 데이터인 '도서' 정보를 유연하고 확장성 있게 관리하기 위한 기반을 다졌습니다.

   * 도서 도메인 모델링 및 Entity 설계
       * 상황: 초기 설계 단계에서 도서 정보의 복잡성(다수의 저자, 출판사, 카테고리 등)으로 인해 데이터 중복과 정합성 문제가 우려되었습니다.
       * 해결: Book을 중심으로 Category, Tag, Publisher, Author 등 도서 관련 핵심 도메인을 정규화하여 Entity를 설계했습니다. JPA 연관 관계 설정 시 무결성을 보장하면서도 성능을 고려한 단방향/양방향 매핑을 적용했습니다.
   * MinIO 기반 객체 스토리지 시스템 구축
       * 상황: 도서 표지 및 상세 이미지와 같은 대용량 비정형 데이터를 DB에 직접 저장할 경우 DB 성능 저하가 예상되었습니다.
       * 해결: 도서 표지 및 상세 이미지 처리를 위해 MinIO(Object Storage)를 도입하고, MinIOService를 통해 파일 업로드/다운로드/삭제 로직을 캡슐화하여 DB 부하를 분산했습니다.
   * 복합 비즈니스 로직 기반 CRUD API 개발
       * 작가, 출판사, 태그 등 여러 연관 리소스를 하나의 트랜잭션 내에서 처리하는 도서 등록/수정 API를 완성했습니다.

  2. \[핵심 기술\] Projection과 JSON을 활용한 조회 성능 최적화 (2025.12.11 ~ 2025.12.25)

  일반적인 JPA 조회 방식에서 발생하는 성능 문제를 Native Query와 DB 함수를 활용해 획기적으로 개선했습니다.

   * 문제 상황 (N+1 문제):
       * 도서 목록 조회 API 호출 시, 각 도서(1)마다 연결된 작가(N), 태그(N), 카테고리(N), 이미지(N) 정보를 가져오기 위해 도서 수만큼 추가 쿼리가 발생하는 N+1 문제에 직면했습니다.
       * 이를 해결하기 위해 단순 Fetch Join을 시도했으나, 1:N 관계가 여러 개 얽혀 있어 데이터 뻥튀기(Cartesian Product) 현상이 발생했고, 이로 인해 페이징 처리가 DB가 아닌 메모리에서 수행되는 심각한 성능 위험이 감지되었습니다.
   * 기술적 해결 (JSON_ARRAYAGG + Projection):
       * Native Query 활용: JPA의 자동 생성 쿼리 대신 nativeQuery = true를 사용하여 최적화된 SQL을 직접 작성했습니다.
       * JSON 함수 이용: MySQL의 `JSON_ARRAYAGG`와 `JSON_OBJECT` 함수를 사용하여, 연관된 1:N 데이터들을 DB 레벨에서 JSON 포맷의 문자열(String)로 집계하여 조회했습니다.
       * Projection 매핑: BookListProjection 인터페이스를 통해 이 JSON 문자열을 그대로 조회(String getAuthors())한 뒤, 애플리케이션 계층(Mapper)에서 객체 리스트로 파싱하여 매핑했습니다.
       * 결과: 수십 번 실행되던 쿼리를 단 한 번의 쿼리(Single Query)로 줄여 조회 성능을 극대화하고 DB 부하를 최소화했습니다.

  3. 프론트엔드 연동 및 캐싱 전략 (2025.11.23 ~ 2026.01.01)

  사용자 경험(UX)을 높이기 위해 프론트엔드와 백엔드 사이의 통신 효율을 높이고 캐싱 전략을 적극 도입했습니다.

   * API 통신 최적화 및 Feign Client 적용 (2025.12.01 ~ 12.03)
       * FrontServer에서 Books-Search 서비스의 데이터를 효율적으로 가져오기 위해 Feign Client를 적용했습니다.
       * 상황: 주문 서비스(Order-Payment)에서 사용자가 결제를 진행하기 전, 수십 개의 도서 ID 목록으로 최신 도서 정보를 일괄 조회해야 하는 상황이 발생했습니다.
       * 해결: 이때 ID 목록을 Query Parameter(GET)로 보낼 경우 URL 길이 제한에 걸리는 문제가 발생하여, 이를 Body에 담아 요청하는 `POST` 기반의 검색 API로 전환하여 대량 데이터 조회 시의 통신 안정성을 확보했습니다.
   * 이미지 프록시(Image Proxy) 구현 (2025.12.09)
       * 상황: 도서 상세 페이지(book-detail.html) 구현 중, 브라우저(HTTPS)에서 MinIO(HTTP)나 내부 네트워크의 이미지를 직접 호출할 때 Mixed Content 오류 및 CORS 정책으로 인해 이미지가 차단되는 문제를 발견했습니다.
       * 해결: FrontServer에 이미지 프록시 컨트롤러(`ImageProxyController`)를 구현하여, 프론트 서버가 백엔드(MinIO)로부터 이미지를 대신 받아 브라우저에 스트림으로 전달하는 중계 로직을 개발했습니다.
   * 이미지 브라우저 캐싱 도입 (2025.12.30 ~ 2026.01.01)
       * 최적화: 이미지 프록시를 통과할 때마다 서버 부하가 발생하는 것을 방지하기 위해, 응답 헤더에 `Cache-Control`을 설정했습니다. 이를 통해 브라우저가 이미지를 로컬에 캐싱하고 재사용하도록 유도하여, 불필요한 네트워크 요청을 줄이고 페이지 렌더링 속도를 획기적으로
         개선했습니다.
   * 계층형 카테고리 관리 및 서버 캐싱 (2025.12.30 ~ 12.31)
       * 구조: 깊이 제한이 없는 무한 계층형 카테고리(Tree Structure)를 구현했습니다.
       * 최적화: 카테고리 정보는 모든 페이지에서 공통으로 사용되며 변경 빈도가 낮고 조회 빈도가 매우 높은 데이터입니다. 매번 DB를 조회하는 비효율을 막기 위해, `FrontServer` 메모리에 전체 카테고리 트리를 캐싱했습니다. 페이지 이동 시마다 DB를 조회하지 않고 메모리에서 즉시
         서빙하여 메뉴 렌더링 속도를 높였습니다.

  4. 관리자 시스템 자동화 및 고도화 (2025.12.23 ~ 2026.01.08)

  운영자의 업무 효율을 높이기 위해 AI 기술과 효율적인 관리 도구를 개발했습니다.

   * Gemini AI 기반 도서 자동 등록:
       * 상황: 관리자가 수많은 도서 정보를 일일이 입력하는 것은 비효율적이었습니다.
       * 해결: 관리자가 ISBN만 입력하면 외부(알라딘 등) 데이터를 Google Gemini AI가 분석하여, 우리 서비스의 카테고리/태그 정책에 맞게 데이터를 정제 및 자동 입력해주는 기능을 구현했습니다.
   * 재고 관리 및 이벤트 처리 (Saga & Facade):
       * 주문 처리(구매) 시: 분산 트랜잭션 처리를 위해 Saga Pattern의 일환으로 SagaHandler를 구현했습니다. RabbitMQ를 통해 전달된 주문 처리(구매) 이벤트(OrderConfirmedEvent)를 수신하면 비동기로 도서 재고를 차감하고, 처리 결과(성공/실패)를 다시 이벤트로 발행하여 데이터 정합성을 보장했습니다.
       * 주문 취소 시: 사용자의 취소 요청 발생 시에는 BookFacade 내의 취소 로직을 직접 호출하여 즉각적으로 재고를 원복하도록 구현했습니다.
   * 메인 페이지 큐레이션:
       * 별도의 복잡한 추천 알고리즘을 사용하는 대신, 신간 도서(발행일 기준)와 금주 추천 도서(관리자 지정 상태)를 효율적인 DB 쿼리로 조회하여 메인 페이지에 노출하는 기능을 구현했습니다.
   * NHN Toast UI Editor 도입:
       * 관리자가 도서 상세 설명이나 리뷰를 작성할 때 텍스트뿐만 아니라 이미지를 포함한 풍부한 콘텐츠를 작성할 수 있도록 위지윅(WYSIWYG) 에디터를 연동했습니다.

  5. 품질 관리 및 문서화 (2026.01.03 ~ 2026.01.08)

   * 테스트 커버리지 확보: Controller, Service, Repository 전 계층에 대한 단위/통합 테스트를 작성하여 코드 변경에 대한 안정성을 확보했습니다.
   * SonarQube 분석: 정적 코드 분석 도구를 통해 코드 스멜과 잠재적 버그를 지속적으로 제거했습니다.
   * 상세 기술 문서화: N+1 문제 해결 방법, 이미지 프로세싱 구조 등 핵심 기술에 대한 상세 문서(docs/)를 작성하여 팀 내 지식 공유를 강화했습니다.
